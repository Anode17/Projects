---
title: "Wine prices prediction from wine reviews dataset"
author: "Bakirov Aslan"
date: "12/11/2020"
output:
  html_document:
    df_print: paged
  pdf_document:
    latex_engine: lualatex
    number_sections: no
fontsize: 11pt
linestretch: 2
urlcolor: blue
---

```{r setup, include=FALSE}
library(data.table)
library(stargazer)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(rebus)
library(stringr)
library(tidytext)
library(textdata)
library(glmnet)
theme_set(theme_pander())
knitr::opts_chunk$set(echo = TRUE,cache = TRUE)
```


```{r loading-data,include=FALSE}

wine_revs<-fread("~/winemag-data-130k-v2.csv",encoding="UTF-8")
```
## Introduction.  
The wine reviews dataset from Kaggle provides users with a myriad of opportunities to explore, visualize, and construct models from using different techniques and is also great for wine lovers to explore. This paper will talk over the methods used to explore the famous dataset and the construction of models, stemming from data exploration, which predict the wine prices.  
 The goal of the project is to create a price-predicting model that uses the variables extracted from the data set to predict the price of the wine. So, a potential user of the model can compare the wine characteristics (e.g variety and vintage) and obtain the price of the bottle similar to what he or she possess. This is supposed to be advantageous for relative valuation of wine bottles in terms of price, similar to house pricing models.   

## Data exploration.  
To begin with, let us fix U.S.A and California as the origin of the wine. Such a decision has two reasons: the chosen location has the highest number of observations (about 36000), and there are too many dimensions, thus it would intricate and enormously expand the model. Also, the dataset provides more information about province, region1 and 2 and designation for U.S.A, while for some countries these are rarely available. The year when the data was scraped last time was 2017, hence we take it as base year where needed.

```{r data-exp,include=FALSE}
# setting country and province in th beginning 
wine_revs <- wine_revs[country=="US"&province=="California"] 
# removing duplicates
anyDuplicated(wine_revs$description)
wine_revs<-wine_revs[!duplicated(wine_revs$description)]
##empty values to NA
wine_revs[designation=="",designation:=NA]
wine_revs[region_1=="",region_1:=NA]
wine_revs[region_2=="",region_2:=NA]
wine_revs[taster_name=="",taster_name:="Missing"]
wine_revs[winery=="",winery:=NA]
wine_revs[variety=="",variety:=NA]
wine_revs[title=="",title:=NA]
```
### Pricing in reality: 
Wine World has it's own pricing segments and specific characteristics such as region, type of grapes, pure one sort or mashup, how a bottle of wine tastes “varietally” correct (typicity), environmental factors in which wine is produced including the soil, climate and topography (terroir) form a wine segment. “Extreme value” wine is the cheapest segment and it usually costs under 4 USD, consumers can expect bulk wine with no distinction. The most expensive segment is Icon, and its price starts from 200 USD,” Icon” is unique wines, wineries, and microsites. If a wine contains terroir, typicity, and  hand craft is presented in its production, then most probably it falls into “Super-premium” segment. It is a median segment, price varies between 20-30$.   
Additionally, wine prices are mostly defined by the cost of the land on which the winery is located. The twisty part is the fact that those land prices are also affected by the prices of wine produced on them, in previous years.Hence in reality the prices of wine are most probably serially autocorrelated.   

```{r wine-prices, echo=FALSE, fig.ncol=2, fig.show='hold', message=FALSE, warning=FALSE, out.width="50%"}
wine_revs<-wine_revs[!is.na(price)]
ggplot(wine_revs,aes(price))+geom_histogram(fill="maroon")+ggtitle(label="Wine price distribuiton",
                                                                 subtitle = "In USD")
ggplot(wine_revs,aes(price))+geom_histogram(fill="maroon")+ggtitle(label="Wine price logarithmic distribuiton")+scale_x_log10()
wine_revs<-wine_revs[price<151]
```
  The price variable, being a numeric, has a skewed distribution and contains huge outliers, as we can see from the histogram with absolute prices. It is better to first convert it to the logarithmic scale and then broom the outliers. This way we save more observations, instead of cutting price under 72USD, we cut it under 150$.  
  Luxurious (Icon) wines for skyrocketing prices usually are traded on auctions and it is unreasonable to include them in the model and expect rational pricing there only based on the variables we have, since in auction case value for individual is essential to know, which we do not know. Additionally, the right-side skewed distribution pinpoints the fact that majority of wines are under 200 dollars. The boxplot confirms this observation.  
  
## Points distribution  

```{r points,echo=FALSE,warning=FALSE,fig.show='hold',fig.ncol=2,out.width="50%"}
#points distribution:  
ggplot(wine_revs,aes(points))+geom_histogram(fill="maroon",binwidth = 1) + ggtitle(label="Distribution of wine ratings")+geom_vline(xintercept = mean(wine_revs$points),type="dashed",col="navy")
wine_revs[,point_cats:=cut(points,breaks = c(79,82,84,86,88,91,max(points)),labels = c("acceptable","good","very good","excellent","superb","classic"))]
ggplot(wine_revs,aes(point_cats,price,alpha=0.3,fill=point_cats))+geom_boxplot(show.legend = F)+scale_y_log10()+ggtitle(label="Distribution of prices by rating categories")+xlab("")+scale_fill_brewer(palette = "Reds")+coord_flip()
```
  The **winemag** journal, from which the dataset has been scraped, provides reviews and concludes points as their conclusion. These points range from 80 to 100, and the wines are classified as Acceptable,Good,Very Good,Excellent,Superb, and Classic. The wines deemed unacceptable (under 80) are not included. The above histogram provides an insight that the wine points are fairly normally distributed. We can not only use points as is, but also create aforementioned categories and include them as factor variables.  
  
## Feature exploration from the description/title.
The title column is extremely useful for the analysis, since it contains one of the most essential traits of wine - its year. The relationship between wine price and its year of production is of a major interest in the real world. Simply including it to our model would not give the whole picture, due to this convoluted relationship. In reality, wine becomes pricier when it ages, yet after hitting a certain extent it expires and starts losing its value. Except for other factors which affect the price through the year, such as the harvest quality during a given year, or possible occurrence of a cosmic event, and even the performance of the economy in a year, this assumption should perfectly hold. To replicate this kind of relationship, I decided to express price as quadratic function of year.  
```{r year-adding,warning=FALSE,echo=FALSE,fig.align='left',out.width="70%"}
### year adding from title:
wine_revs[,year:=as.numeric(str_extract(title,DGT%R%DGT%R%DGT%R%DGT))]
wine_revs[,year_count:=str_count(title,DGT%R%DGT%R%DGT%R%DGT)] # some titles contain two four-digit numbers, those columns would be hard to extract exact year, so we just ignore them.
wine_revs[year_count>1,year:= NA]
wine_revs[,year_count:=NULL]

# There are some cases when the function takes the wrong year from title, and also there are not available years, which are minority, and can be excluded (since we don't know how to extract them)

wine_revs<-wine_revs[!is.na(year)]
ggplot(wine_revs[variety=="Pinot Noir"],aes(year,price,group=year,alpha=0.01))+geom_boxplot(fill="darkred",show.legend = F)+scale_y_log10()+scale_x_continuous()+ggtitle(label="Pinot Noir prices over the years",subtitle = "Base year is 2017")
```
### Oaked and non-oaked wines.  
Among other features extracted from description/title, are oak, showing whether a wine was contained in oak barrels. The oaked wines have a tendency to be more expensive, since the containers themselves are costly (a couple of thousand dollars for a new one). Apart from this straightforward reason, another advantage is the oaky notes which take the taste of wine to a whole new level of richness. The oak feature has been examined during our bootstrapping homework where we checked whether the oaked wines are pricier than the rest.  
```{r oaked-feature-adding,include=FALSE}
# oaked
wine_revs[, oaked := grepl("oak", tolower(description))]
#wine_revs[,table(oaked)]
```
### Reserved wines  
Another feature capturing our interest is whether the wine is reserve or not. The idea is that winemakers reserve a portion of a rare quality vintage wine, thus ensuring that wine is also aged. This quality is represented by the label on a bottle, and the validity of the label is regulated in some countries. For instance, in Spain it is a must for a wine to be preserved at least 3 years, 6 months of which should be in oak barrels to put the label "Riserva". Yet, some countries have no back-up for the whole reserve story and thus it is of greater importance, especially in US, where no regulation binds winemakers to reserve a wine for a couple of years before putting “reserve” on the bottle. The hypotheses that prices are the same have been rejected at extremely significant levels, stating that at least the Californian wines we have in the dataset, follow the tradition.  
```{r reserved-wines,echo=FALSE}
#reserved
wine_revs[, reserved := grepl("reserve", tolower(title))]
wine_revs[,table(reserved)]
t.test(wine_revs[reserved==1,price],wine_revs[reserved==0,price])
```
### Vintage wines.  
The vintage is the reference to the year of the grapes from which the wine was made. In other words, vintage wines are the ones in production of which goes the harvest of one particular year. On the other hand, wines that are made from a mix of grapes from distinct years, are marked as non-vintage (NV). I decided to parse it from the description to get some insight from the taster, since almost all wines at this step can be considered vintage. It happened when I ditched the NA values from year column. Thus, this vintage column represents wines which are recognized by the taster and hence the description of the wine contains the word vintage.   
```{r vintages,include=FALSE}
#vintage wines
wine_revs[,vintage:=str_extract(tolower(description),"vintage")]
wine_revs[,vintage:=ifelse(is.na(vintage),0,1)]
wine_revs[,table(vintage)]
#t.test(wine_revs[vintage==1,price],wine_revs[vintage==0,price])
```
## Text analysis
### The number of words and number of charachters.  
Next, I decided to make use of one most important column and applied text analysis with *tidytext* package to unnest words from the descriptions. The aforementioned step is also used to add two new variables – number of words and number of characters in description for each wine, since it might be the case that these are strongly correlated.  
```{r words-in-the-description,include=FALSE}
# number of words in description
desc_text<-wine_revs %>% select(description,V1,points) %>%
  unnest_tokens(word,description) %>% 
  mutate(nchars=nchar(word))
wine_revs<-left_join(wine_revs,desc_text[,.(nwords=.N,nchars=(sum(nchars))),V1],by="V1")
#glimpse(wine_revs)
```
### Sentiment analysis.  
We have established above that the description is the most important column in our dataset, yet it is to blunt to measure the effect of the vast description on the price. A taster can say a myriad of words to express a neutral position on the particular wine, as well as positive. In an attempt to understand the attitude of the taster, I took the *AFINN lexicon* for a light sentiment analysis, which sorts words by a score from -5 to +5 according to their attitude (negative-positive). Then, I added another variable as a sum of all those sentiments in the description of the wine. Now I estimate how price changes when the taster use a slightly more positive word(s).  
```{r sentiment scores for words,results='hide'}
# quantitative representation of sentiment with afinn:
desc_text<-
anti_join(desc_text,stop_words,"word") %>% 
  filter(word!="wine") %>% 
           filter(word!="drink") %>% 
  mutate(sent_num=0) %>% 
  left_join(get_sentiments("afinn"),by="word") %>% .[is.na(value)==T,value:=0]
# excluding oaked words:
desc_text<-desc_text[!str_detect(desc_text$word,
                                 "oak"%R%optional(ANY_CHAR)%R%optional(ANY_CHAR))&
                       !str_detect(desc_text$word,DGT%R%optional(DGT))&
                       !str_detect(desc_text$word,
                                 "reserve"%R%optional(ANY_CHAR)%R%optional(ANY_CHAR))&
                       !str_detect(desc_text$word,
                                 "vintage"%R%optional(ANY_CHAR)%R%optional(ANY_CHAR))]
## the variety and region names to be excluded:
wine_names<-unnest_tokens(wine_revs,wine_names,variety) %>% .[,unique(wine_names)]
desc_text<-desc_text[!word%in%wine_names]
reg_names<-unnest_tokens(wine_revs,wine_names,region_1) %>% .[,unique(wine_names)]
desc_text<-desc_text[!word%in%reg_names]
wine_revs<-left_join(wine_revs,desc_text[,.(sentiment=sum(value)),V1],"V1")
#glimpse(wine_revs)
```
## Grouping and adding all variables together.  
Some of the most frequently appearing varieties (e.g., Pinot Noir) and regions such as Napa Valley are distinguished, and the rest of these columns were grouped as factor stating that they represent Other variety and region. This is an easing step to include some of the important variables to the model without over-complicating it. Afterwards, all these factor levels are casted into dummy new columns and added to the set of predictors.  
```{r grouping-and-casting,echo=FALSE,message=FALSE,warning=FALSE}
# Grouping most frequent regions:
regions<-wine_revs[,.N,region_1][order(-N)] %>% transmute(N,region_1=ifelse(N<1000,"Other region",region_1))
wine_revs<-left_join(wine_revs,regions,"region_1") %>% .[is.na(N),region_1:="Other region"]
# Variety:
variety<-wine_revs[,.N,variety][order(-N)] %>% transmute(N,variety=ifelse(N<1000,"Other variety",variety))
wine_revs<-left_join(wine_revs,variety,"variety") %>% .[is.na(N.y),variety:="Other variety"]
#Ditching the excess columns
wine_revs[,N.x:=NULL]
wine_revs[,N.y:=NULL]
# sub-regions which overlap:
wine_revs[region_1=="Other region",.(subregion=unique(region_2),.N)] %>%
  inner_join(wine_revs[region_1!="Other region",.(unique(region_2),.N), region_1],c("subregion"="V1"))
```
 After grouping, we should pay attention to the sub-regions within regions, since they may overlap. In US that may happen since the division does not follow clear geographical pattern, instead the division is made in accordance with the set of geopolitical factors (from soil quality to special legal aspects).  
In particular, notice an overlap of sub-regions in Russian River Valley, Sonoma Coast, Sonoma County and Other regions, all these have sub-regions named Sonoma. Besides, this issue occurs with Napa Valley, Paso Roble regions too. One solution to this is to add these sub-regions occurring several times as dummy variables, and in the model include as interaction variable with clearly defined regions. Thus, we would have price effect of wine's location in Sonoma-Russian River Valley apart from effect of Sonoma-Other region. This way we fully establish grounds for leaving the "Other" factor level as the base to compare the rest with.   
```{r grouping-cont,include=FALSE}
subRegion2Column<-function(string){
  wine_revs[,paste0(tolower(string)):=ifelse(region_2==string,1,0)]
}
subRegion2Column("Sonoma")
subRegion2Column("Napa")
subRegion2Column("Central Coast")
subRegion2Column("California Other")
wine_revs<-wine_revs[!is.na(region_2)]
```
### Adding most frequent words and casting.  
Finally, I use a thousand of the most commonly used words in the dataset, to add to our models. The words we have cleaned above are supposed to present a greater help in contrast with such methods as tf-idf, which if applied for description, would only give us exclusive words for one particular wine, not helping much with predictions.  
 Afterwards, let's finalize the data exploration with modifying our dataset from long to wider form, adding binary variables for each of factor levels in columns. I leave out grouped categories as base levels, and well defined factors as predictors which should compare to the base category.     
```{r adding-words-as-columns, echo=FALSE, message=FALSE, warning=FALSE}
### casting factors into binary columns
wine_revs<-left_join(wine_revs,dcast(wine_revs,V1~factor(taster_name),fun.aggregate=length),"V1")
wine_revs<-left_join(wine_revs,dcast(wine_revs,V1~factor(variety),fun.aggregate=length),"V1")
wine_revs<-left_join(wine_revs,dcast(wine_revs,V1~factor(region_1),fun.aggregate=length),"V1")
wine_revs<-left_join(wine_revs,dcast(wine_revs,V1~factor(point_cats),fun.aggregate=length),"V1")
#adding words
imp_words<-desc_text[word!="cola"&!word%in%tolower(names(wine_revs[,1:21])),.N,word][order(-N)][1:1000,]
for(i in 1:1000){
  wine_revs[,paste0(imp_words[i,word]):=ifelse(str_detect(description,imp_words[i,word]),1,0)]
}
```
## Model building.  
Firstly, let's subset our data into the train and test sets in the 75/25 ratio. I am training  models and then using them to predict prices in the test set. While building models I tried to include all the features which have been revealed in the data exploration part. The basis for predicting the price of a Californian wine is comprised of its region within the state, its sub-region (for a couple of regions), variety, year, taster's name, 1000 most frequent words used by the tasters for various wines, rating category (base-Acceptable), number words and characters in the description, sentiment score for the description, whether the wine is oaked, reserved and vintage.   
Two of these models are linear regressions, one only including all the predictors, and the other containing additional interactive terms and quadratic form of year. Furthermore, I used the regularised regressions, with 4-fold cross validation to penalize for large number of variables. 
```{r data-splitting,include=FALSE}
library(caret)
data=
  wine_revs %>%
  select(
    -c(country,V1,designation,description,point_cats,province,region_1,region_2,taster_name,taster_twitter_handle,variety,winery,title,`Other region`,`Other variety`,acceptable,Missing))

data[,price:=log(price)]
set.seed(1736)
index<-createDataPartition(1:nrow(data),p=0.75,list=F)
train=data[index]
test=data[-index]

```

```{r models,echo=FALSE,warning=FALSE,message=FALSE,error=FALSE}
##glm models
model1<-glm(price~.-points,data=train,family = "gaussian" )
model2<-glm(price~.-points+sentiment*nwords+I(year^2)+nchars/nwords+
              sonoma*`Russian River Valley`+sonoma*`Sonoma County`+
              sonoma*`Sonoma Coast`+napa*`Napa Valley`+
              `central coast`*`Paso Robles`+`California`*`california other`,
            data=train,family = "gaussian" )
# regularized regressions
set.seed(1736)
trc<-trainControl(method="cv",number = 4)

ridge_cv<-caret::train(price~.-points+sentiment*nwords+I(year^2)+nchars/nwords+
              sonoma*`Russian River Valley`+sonoma*`Sonoma County`+
              sonoma*`Sonoma Coast`+napa*`Napa Valley`+
              `central coast`*`Paso Robles`+`California`*`california other`,
              data=train,method="glmnet",trControl=trc,tuneGrid = 
                      expand.grid(alpha = 0, lambda = 10^seq(-3,0,length=20)))
ridge_cv
lasso_cv<-caret::train(price~.-points+sentiment*nwords+I(year^2)+nchars/nwords+
              sonoma*`Russian River Valley`+sonoma*`Sonoma County`+
              sonoma*`Sonoma Coast`+napa*`Napa Valley`+
              `central coast`*`Paso Robles`+`California`*`california other`,
                         data=train,method="glmnet",trControl=trc,tuneGrid = 
                         expand.grid(alpha = 1, lambda = 10^seq(-4,0,length=30)))
lasso_cv
calculateRMSE<-function(actual,predicted){sqrt(mean((actual-predicted)^2))}


train_pred<-data.table(model1=calculateRMSE(train$price,fitted(model1)),
           model2=calculateRMSE(train$price,fitted(model2)),
           lasso_cv=calculateRMSE(train$price,fitted(lasso_cv)),
           ridge_cv=calculateRMSE(train$price,fitted(ridge_cv)))
#Predicting
predict_m1<-predict(model1,newdata = test)
predict_m2<-predict(model2,newdata = test)
predict_lasso<-predict(lasso_cv,newdata = test)
predict_ridge<-predict(ridge_cv,newdata = test)

test_pred<-data.table(model1=calculateRMSE(test$price,predict_m1),
           model2=calculateRMSE(test$price,predict_m2),
           lasso_cv=calculateRMSE(test$price,predict_lasso),
           ridge_cv=calculateRMSE(test$price,predict_ridge))
```

```{r last,echo=FALSE}
stargazer(rbind(train_pred,test_pred),title="RMSE",summary=F,type="html")
```
  In the table we can observe how each model performed in practice. The first row presents the RMSE statistics obtained from training data, and the second is for test data. As it could have been expected, the regularized LASSO model performed  better than others, most probably due to the fact that we included more than a thousand of variables and those are mostly correlated and hence-penalized.  

  
```{r lastt,echo=FALSE,out.width="70%"}
plot(varImp(lasso_cv,scale = F),top=20) # most important variables ranked by their effect on price, in %.
```
  
## Conclusion.    

To sum up, the wine reviews dataset proves to be rich in data exploration, which is fantastic for getting features out of it, yet the models we can build on it are only one-sided. The price prediction model does not take into account either costs to winemaker, or the fact that the price of wine depends also on the price of the land, which in turn depends of the previous years' prices of wines. Nonetheless, the model is good to  predict and reveals that, for instance, if *Michael Schachner* tasted the *Pinot* from *Sonoma County*, and in his verdict used the word *priced*, it would cost almost 100% more than another *acceptable* wine from *Other region*, and *Other variety*. Ultimately, these aspects can be applied to conduct relative valuation of wines with respect to base levels.